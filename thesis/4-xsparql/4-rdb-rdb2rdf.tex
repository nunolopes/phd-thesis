\section{Processing RDB2RDF Mappings in XSPARQL}
\label{sec:examples-rdb2rdf}

The W3C RDB2RDF Working Group (WG) is currently in the process of defining a standard language to translate a relational
database into \ac{RDF}.  
%
The WG has defined 2 documents: the \emph{Direct Mapping (DM)}~\cite{ArenasPrudhommeauxSequeda:2011aa} specifies the
process of translating a relational database into \ac{RDF} in an automated manner, and the \emph{R2RML} language
definition~\cite{DasSundaraCyganiak:2011aa} corresponds to a user specified translation (in Turtle syntax) of the input
relational database.  The direct mapping provides a generic representation of the relational database while the R2RML
provides more fine-tuned control over the produced \ac{RDF}.

Next we start by giving an overview of the RDB2RDF Direct Mapping, the R2RML language, and then provide an algorithm for
the implementation of R2RML in XSPARQL.

\subsection{Direct Mapping}
\label{sec:direct-mapping}

The aim of the DM is to provide an \emph{off-the-shelf} translation of relational databases into \ac{RDF}, \ie~a
transformation that requires minimal user input.  
%
This translation follows already existing approaches, implemented by several conversion tools, and relies on creating
the output \ac{RDF} graph by assigning a unique identifier to each tuple in a relation from the input database.  This
identifier is created based on the relation name and the values for any existing primary keys and is then used as the
subject of each \ac{RDF} triple generated from the specific tuple.\footnote{In case a relation does have any primary
  keys a distinct blank node is used as an identifier for each tuple.}
%
Attributes names are used to generate a \ac{URI} that is used as a predicate, while the object consists of the value for
the specific attribute.
%

For processing DM in XSPARQL we need to have access to the underlying relational schema.  For this we rely on a custom
function that returns an \ac{XML} representation of the relational schema and, based on this representation, the DM
implementation is similar to the R2RML mappings, where we can use \SQLForClause{s} to access the relational database and
generate the target \ac{RDF} graph.
%
In the rest of this section we will focus on R2RML mappings and describe in more detail the XSPARQL query used to
implement such transformations.


\subsection{The R2RML mapping language}
\label{sec:r2rml-mapp-lang}

The R2RML mapping is itself an \ac{RDF} graph consisting of several \stt{TriplesMap}, that specify how to map a
\emph{logical table} in the input relational database into \ac{RDF}.  The \emph{logical table} can correspond to a
table, a view in the database, or the result of a SQL query to be executed over the input relational
database.\footnote{Arbitrary SQL queries can be executed in XSPARQL via an implementation-defined XQuery function and
  were included only to cater for this feature of R2RML.}


Each \stt{TriplesMap} consists of one \stt{SubjectMap} and possibly multiple \stt{Predicate\-ObjectMaps}.  Each row in
the logical table produces a single \emph{subject} in the target \ac{RDF}, which is specified by the \stt{SubjectMap}.
The multiple \stt{PredicateObjectMaps} each specify how to generate a \emph{predicate} and possibly several
\emph{objects} (by means of \stt{PredicateMaps} and \stt{ObjectMaps}, respectively) that are related to the generated
\emph{subject}.

\begin{figure}[t]
  \centering
  \lstinputlisting[escapeinside={\#@}{\^^M}]{0-data+queries/bands-rdb2rdf.ttl}
  \caption{RDB2RDF mapping for tables ``band'' and ``person''}
  \label{fig:rdb2rdf-band}
\end{figure}

Furthermore, each \stt{SubjectMap}, \stt{PredicateMap}, and \stt{ObjectMap} can specify how the \ac{RDF} term is created
by using different \ac{RDF} predicates.  For instance, using the \texttt{column} predicate for the mapping rule (\eg~the
predicate of the \stt{ObjectMap} on \cref{fig:rdb2rdf-band-column} of \cref{fig:rdb2rdf-band}) indicates that
the \ac{RDF} object should be generated based on the value of the column in the input database.
%
Another example is the \texttt{template} predicate, which specifies how terms are generated by using a template that
will be instantiated with values from the logical table, \eg~the \stt{subjectMap} from \cref{fig:rdb2rdf-band-template}
of \cref{fig:rdb2rdf-band}, states that the generated subject should be of the format
%
\begin{verbatim}
      http://example.com/band/{bandId}
\end{verbatim}
%
where \stt{\{bandId\}} is to be replaced by the value of the \stringValue{bandId} attribute in the specific tuple.
%
The other predicate used in the example from \cref{fig:rdb2rdf-band} is \qname{rr}{predicate}
(\cref{fig:rdb2rdf-band-predicate}), which states that the predicate of the generated triples should be
\qname{foaf}{name}.

Finally, foreign keys can be specified using \stt{RefObjectMap} and by indicating the \stt{TriplesMap} that represents
the foreign logical table and possibly a \stt{joinCondition} that specifies how to merge the two relations, as shown in
\crefrange{fig:rdb2rdf-band-parentTriplesMap}{fig:rdb2rdf-band-joinCondition} of \cref{fig:rdb2rdf-band}.

An R2RML mapping produces an \ac{RDF} dataset with all the generated triples belonging to the default graph unless
otherwise stated.
%
To cater for the possibility of creating triples in a named graph, we extend XSPARQL's generation of \ac{RDF} graphs in
Turtle format to generate an N-Quads representation~\cite{CyganiakHarthHogan:2009aa} of the \ac{RDF} data.
%
This extension is also used and is further expanded in \cref{cha:usecase}.


\subsection{R2RML Implementation in XSPARQL}
\label{sec:r2rml-xsparql}


\SetKw{From}{from}
\SetKw{Row}{row}
\SetKw{SPARQLForClause}{for}
\SetKw{kwLet}{let}
\SetKw{In}{in}
\SetKw{Assign}{\textbf{:=}}
\SetKwBlock{Where}{where}{}
\SetKwBlock{Construct}{construct}{}
\SetKwBlock{Return}{return}{}
\SetKwFunction{createTerm}{createTerm}
\SetKwFunction{createSubject}{createSubject}
\SetKwFunction{createLiteral}{createLiteral}
\SetKwFunction{createURI}{createURI}
\SetKwFunction{Value}{value}
\SetKwFunction{getLogicalTable}{getLogicalTable}
\SetKwFunction{createPO}{createPO}
%
\begin{algorithm}[t]
  \caption{\fc{rdb2rdf}{\var{m}} }
  \label{algo:rdb2rdf}
  \DontPrintSemicolon
  \SetNlSty{textrm}{}{}
  \KwIn{RDB2RDF mapping~$\var{m}$ (represented as RDF)}
  \KwResult{RDF Graph}
  \kwLet \var{mapSk} \Assign skolemise(\var{m}) \; \nllabel{skolem}
  \SPARQLForClause * \From{\var{mapSk}}\; \nllabel{loop-TriplesMap-start}
  \Where{ \var{map} rdf:type TriplesMap;  rr:logicalTable \var{table}; rr:subjectMap \var{s} . \;}
  \Return{
    \For{\Row \var{tableRow} \In \getLogicalTable{\var{table}}}{\nllabel{getTable}
      \kwLet \var{subject} \Assign \createSubject{\var{mapSk}, \var{tableRow}, \var{s} } \; \nllabel{createSubject}
      \createPO{\var{mapSk}, \var{tableRow}, \var{subject}, \var{map}} \nllabel{createPO}
    }
  }\nllabel{loop-TriplesMap-end}
\end{algorithm}

In this section we present an algorithm that implements the R2RML transformation in XSPARQL.
%
This transformation is implemented as an XSPARQL query but, for readability purposes, is summarised in
\cref{algo:rdb2rdf}.  
%
In this algorithm we rely on multiple queries to the R2RML input mapping file and since the R2RML representation may use
blank nodes for describing the mapping, we start by \emph{skolemising} blank nodes in the input \ac{RDF} graph, \ie~any
blank nodes used in the R2RML mapping are substituted with newly generated URIs that are distinct from any other URI in
the graph. This transformation allows us to use these newly generated URIs to merge data across different queries and is
represented in the algorithm by the~$\mathit{skolemise}$ function (line~\ref{skolem}).

The \SparqlForClause on lines~\ref{loop-TriplesMap-start}--\ref{loop-TriplesMap-end} iterates over all the
\stt{TriplesMaps} present in the mapping file and, for each of these \stt{TriplesMaps}, retrieves the specified data
from the input relational database.
%
This access to the (logical) table of the relational database is represented by the \SQLForClause on
line~\ref{getTable}, which instantiates \var{row} for each result row that the corresponding \ac{SQL} query returns (as
described in \cref{sec:syntax}).  The function \stt{getLogicalTable} is responsible for processing the different
available forms of specifying the input relation in R2RML.
%
In line~\ref{createSubject} we generate the \emph{subject} that is shared by all the triples derived from the same row
of the relation and pass it to the \stt{createPO} auxiliary function (line~\ref{createPO}) that takes care of generating
the predicate-object pairs.


\begin{algorithm}[t]
  \caption{\fc{createPO}{\var{mapSk}, \var{row}, \var{subject}, \var{map}} }
  \label{algo:createPO}
  \DontPrintSemicolon
  \SetNlSty{textrm}{}{}
  \KwIn{skolemised RDB2RDF mapping \var{mapSk}, Database data \var{row}, generated RDF term \var{subject}, input RDF term \var{po}}
  \KwResult{RDF Graph}
  \SPARQLForClause * \From{\var{mapSk}} \; \nllabel{pred-obj1}
  \Where{ \var{map} rr:predicateObjectMap [ rr:predicateMap \var{p};  rr:objectMap \var{o} ] \;} \nllabel{pred-obj2}
  \Return{
    \kwLet \var{predicate} \Assign \createTerm{\var{mapSk}, \var{row}, \var{p}} \; \nllabel{create-pred}
    \kwLet \var{object} \Assign \createTerm{\var{mapSk}, \var{row}, \var{o}} \; \nllabel{create-obj}
    \Construct{ \var{subject} \var{predicate} \var{object}}
  }
\end{algorithm}
%
The \textit{createPO} function described in \cref{algo:createPO} retrieves all the \stt{predicateMap} and
\stt{objectMaps} associated with the \stt{TriplesMap} we are processing (lines~\ref{pred-obj1}-\ref{pred-obj2}), creates
the respective \emph{predicate} (line~\ref{create-pred}) and \emph{object} (line~\ref{create-obj}) and then generates an
\ac{RDF} triple using the XSPARQL built-in \CONSTRUCT expression.  The \CONSTRUCT expression automatically takes care of
discarding any non-valid \ac{RDF} triples.



\begin{algorithm}[t]
  \caption{\fc{createTerm}{\var{mapSk}, \var{row}, \var{spec}} }
  \label{algo:createTerm}
  \DontPrintSemicolon
  \SetNlSty{textrm}{}{}
  \KwIn{skolemised RDB2RDF mapping \var{mapSk}, Database data \var{row}, RDF term specification \var{spec}}
  \KwResult{RDF Term}
  \SPARQLForClause * \From{\var{mapSk}}\; \nllabel{spec-type1}
  \Where{ \var{spec} \var{specType} \var{specValue} \;} \nllabel{spec-type2}
  \Return{\nllabel{return1}
    \uIf{\var{specType} == rr:predicate}{createURI(\var{specValue})}
    \uElseIf{\var{specType} == rr:column}{\createLiteral{\Value{\var{row}, \var{specValue}}}}
    \lElse{\dots}\nllabel{return2}
  }
\end{algorithm}
%
The auxiliary function \stt{createTerm} is partially presented in \cref{algo:createTerm}: given a specific database
table \emph{\$row}, this function produces an \ac{RDF} term according to the specification given in the RDB2RDF mapping.
The \SparqlForClause from lines~\ref{spec-type1}-\ref{spec-type2} takes care of querying the RDB2RDF mapping to
determine the type of the \ac{RDF} term to be produced. Finally, the \textbf{return} clause
(lines~\ref{return1}-\ref{return2}) presents the process of creating \ac{RDF} terms for the \qname{rr}{predicate} and
\qname{rr}{column} types of specifications.  The \stt{createURI} and \stt{createLiteral} functions used in this
algorithm are XSPARQL built-in functions that behave as constructors for \acp{URI} and literals, respectively.
%
The \stt{value} function returns the value associated with a column name in an \stt{SQLResult} (similar to the formal
semantics function presented in \cref{sec:fs:value}).
%
The missing RDB2RDF specifications are similar to the presented ones possibly requiring some extra processing, \eg~the
\qname{rr}{template} specification needs to be parsed to extract the column names from the template and then access
their values of the current row.



\begin{data}[t]
  \centering
  \lstinputlisting{0-data+queries/bands-rdb2rdf-output.ttl}
  \caption{Output of algorithm rdb2rdf (\cref{algo:rdb2rdf})}
  \label{fig:rdb2rdf-example-output}
\end{data}
%
\cref{fig:rdb2rdf-example-output} presents the \ac{RDF} graph resulting from the applying
\cref{algo:rdb2rdf} to the RDB2RDF mapping presented in \cref{fig:rdb2rdf-band}.






%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% mode: reftex
%%% TeX-master: "../thesis"
%%% End:
